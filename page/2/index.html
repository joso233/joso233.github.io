
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <title>叫兽の窝</title>
    <link rel="stylesheet" href="/css/dark-mode.css">
    <script src="/js/dark-mode.js"></script>
    

    <meta name="author" content="joso" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
    <script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
    <script src="/js/fireworks.min.js"></script>
    <canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
    <script src="/js/background.min.js"></script>
    <div id="cursor"></div>
    <link rel="stylesheet" href="/css/cursor.min.css">
    <script src="/js/cursor.min.js"></script>
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />


    <script src="/js/lib/toc.js"></script>



<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<link 
    rel="stylesheet"
    id="highlight-style-dark"
    disabled
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github-dark.min.css"
/>
<script src="/js/lib/highlight.js"></script>



    <meta name="msvalidate.01" content="BF22997B7BE5F5F14F0E8845B35BAD3F" />
<script>
        new Darkmode().showWidget();
</script>

<meta name="generator" content="Hexo 7.3.0"></head>
<body>

    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>叫兽の窝</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;关于</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;博客</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;分类</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;叫兽の窝</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">关于</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">博客</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">分类</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>叫兽の窝</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/09/26/%E6%8D%A2%E6%A0%B9dp/">
        <h2 class="post-title">换根dp</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <!-- toc -->

<ul>
<li><a href="#%E6%A0%91%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84">树的最长路径</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li>
<li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="树的最长路径">树的最长路径</span></h1><h2><span id="题目">题目</span></h2><p><img src="https://joso-1302558797.cos.ap-nanjing.myqcloud.com//imgimage-20240926193757033.png" alt="image-20240926193757033"></p>
<h2><span id="思路">思路</span></h2><p>这道题的前置知识点可以参考[树的最长路径](<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1074/">1072. 树的最长路径 - AcWing题库</a>)easy版，核心代码如下：</p>
<pre><code class="c++">void up(int u,int fa)&#123;
    st[u]=1;
    for(auto v:e[u])&#123;
        if(v.to==fa) continue;
        up(v.to,u);
        if(f[u][1]&lt;=f[v.to][1]+v.w)&#123;
            f[u][2]=f[u][1];
            f[u][1]=f[v.to][1]+v.w;
        &#125;
        else if(f[u][2]&lt;=f[v.to][1]+v.w)&#123;
            f[u][2]=f[v.to][1]+v.w;
        &#125;
    &#125;
&#125;
</code></pre>
<p>以某点为根的子树的最长路径即为以该点为根的最长路与次长路的长度和，一遍dfs即可求出所有子树的最长路径，但在这个题里，显然某点的最长路径不一定存在于某点的子树中，而存在于该点的根节点里面，这个时候就需要引入<strong>换根</strong>的概念了</p>
<p><img src="https://joso-1302558797.cos.ap-nanjing.myqcloud.com//img1b396cad67460d0e5dd0ad21f18fc608.jpg" alt="img"></p>
<p>​	如图给出了一颗树，当以1为根时，显然他的最长直径为路径1-3-7-11（f[1] [2]&#x3D;3,一维表示以1为根，二维表示第2长的路）与路径1-4-9-13-15（f[1] [1]&#x3D;4）的长度和7.</p>
<p>​	但当我们考虑结点4时,第一遍dfs跑出来的结果p[4] [1]&#x3D;3,p[4] [2]&#x3D;2,显然不是最优的，因为把结点1看作他的子节点时，f[4] [1]可以被f[1] [2]+1替换，同理f[3] [1]可以被f[1] [1]+1替换，f[3] [2]继承 f[3] [1]。</p>
<p>​	如果此时我们对每个节点都跑一遍dfs的话可以解决这个问题，但其时间复杂度为O(n^2) 的，显然不符合题面的要求，所有需要考虑怎么在O(n)的时间复杂度下得出每点的答案，这个时候对每个结点观察可以看出，答案是否需要更新只和他的根节点信息有关，当根节点长度大于p[i][1]或者p[i][2]时按需求更新答案即可。</p>
<p>​	具体的更新答案的情况有两类，一种是子节点v被父节点u的第一长路径覆盖，另一种则是被第二长路径覆盖或不被覆盖。</p>
<p>​	当我们考虑第一种情况是，对应图中的v&#x3D;4号结点，当前结点v被根节点u的第一长的路径包括在内，v的第一长的路径长度一定是最优的，但需要考虑f[v] [2]与f[u] [2]+1的关系。第二种情况对应v&#x3D;2或者v&#x3D;3，此时根节点u中一定存在一条最优的路径大于p[v] [1]与p[v] [2]，因为根结点在寻找最长路径时没有考虑经过子节点v，所以子节点v中的任何路径都是非最优解，那么直接将p[v] [2]更新为p[v] [1],并用p[u] [1]+1替换p[v] [1]。</p>
<p>​	注意在每一次更新都要维护当前的结点所选的每一条路都要经过的那个子节点，用来后续判断某个点是否为父节点所选</p>
<h2><span id="代码">代码</span></h2><pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N = 2e6 + 10;
typedef pair&lt;int,int&gt; PII;
bool st[N];
struct tree&#123;
    int to;
&#125;;
int size[N],f[N][3],p[N][3];
vector&lt;tree&gt; e[N];
void up(int u)&#123;
    st[u]=1;
    for(auto v:e[u])&#123;
        if(st[v.to]) continue;
        up(v.to);
        if(f[u][1]&lt;f[v.to][1]+1)&#123;
            f[u][2]=f[u][1];
            p[u][2]=p[u][1];
            f[u][1]=f[v.to][1]+1;
            p[u][1]=v.to;
        &#125;
        else if(f[u][2]&lt;f[v.to][1]+1)&#123;
            f[u][2]=f[v.to][1]+1;
            p[u][2]=v.to;
        &#125;
    &#125;
&#125;
void down(int u)&#123;
    st[u]=1;
    for(auto v:e[u])&#123;
        if(st[v.to]) continue;
        if(p[u][1]==v.to)&#123;
            if(f[v.to][1]&lt;f[u][2]+1)&#123;
                f[v.to][2]=f[v.to][1];
                p[v.to][2]=p[v.to][1];
                f[v.to][1]=f[u][2]+1;
                p[v.to][1]=u;
            &#125;
            else if(f[v.to][2]&lt;f[u][2]+1)&#123;
                f[v.to][2]=f[u][2]+1;
                p[v.to][2]=u;
            &#125;
        &#125;
        else&#123;
            f[v.to][2]=f[v.to][1];
            p[v.to][2]=p[v.to][1];
            f[v.to][1]=f[u][1]+1;
            p[v.to][1]=u;
        &#125;
        down(v.to);
    &#125;
&#125;
void solve()&#123;
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;n;i++)&#123;
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        e[u].push_back(&#123;v&#125;);
        e[v].push_back(&#123;u&#125;);
    &#125;
    up(1);
    for(int i=1;i&lt;=n;i++) st[i]=0;
    down(1);
    int ans=0;
    for(int i=1;i&lt;=n;i++)&#123;
        cout&lt;&lt;f[i][1]+f[i][2]&lt;&lt;endl;
    &#125;
&#125;
signed main()&#123;
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t=1;
    //cin &gt;&gt; t;
    while (t--) &#123;
        solve();
    &#125; 
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c/" style="color: #03a9f4">c++</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="color: #00bcd4">动态规划</a>
        </span>
        
    </div>
    <a href="/2024/09/26/%E6%8D%A2%E6%A0%B9dp/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/24/AtCoder-Beginner-Contest-372/">
        <h2 class="post-title">AtCoder Beginner Contest 372</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E9%A2%98%E8%A7%A3/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <!--toc-->

<h1><span id="d-buildings"><strong>D - Buildings</strong></span></h1><h3><span id="problem-statement">Problem Statement</span></h3><p>There are $N$ buildings, Building $1$, Building $2$, $\ldots$, Building $N$, arranged in a line in this order. The height of Building $i$ $(1 \leq i \leq N)$ is $H_i$.</p>
<p>For each $i &#x3D; 1, 2, \ldots, N$, find the number of integers $j$ $(i &lt; j \leq N)$ satisfying the following condition:</p>
<ul>
<li>There is no building taller than Building $j$ between Buildings $i$ and $j$.</li>
</ul>
<h3><span id="constraints">Constraints</span></h3><ul>
<li>$1 \leq N \leq 2 \times 10^5$</li>
<li>$1 \leq H_i \leq N$</li>
<li>$ H_i\neq H_j\ (i\neq j)$</li>
<li>All input values are integers.</li>
</ul>
<h3><span id="sample-input-1">Sample Input 1</span></h3><pre><code>5
2 1 4 3 5
</code></pre>
<h3><span id="sample-output-1">Sample Output 1</span></h3><pre><code>3 2 2 1 0
</code></pre>
<p>For $i&#x3D;1$, the integers $j$ satisfying the condition are $2$, $3$, and $5$: there are three. (Between Buildings $1$ and $4$, there is a building taller than Building $4$, which is Building $3$, so $j&#x3D;4$ does not satisfy the condition.) Therefore, the first number in the output is $3$.</p>
<h2><span id="实现">实现</span></h2><p>倒着将元素挨个放入单调栈，栈的元素个数即为当前位置的答案</p>
<pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N = 2e5 + 10;
int a[N],b[N],c[N];
stack&lt;int&gt;st;
void solve()&#123;
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;a[i];
    &#125;
    for(int i=n;i&gt;=1;i--)&#123;     
        b[i]=st.size();
        while(!st.empty()&amp;&amp;a[i]&gt;st.top())&#123;
            st.pop();
        &#125;
        st.push(a[i]);
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        cout&lt;&lt;b[i]&lt;&lt;&#39; &#39;;
    &#125;
    cout&lt;&lt;endl;
&#125;
signed main() &#123;
    int t=1;
    //cin &gt;&gt; t;
    while (t--) &#123;
        solve();
    &#125;
       
&#125;
</code></pre>
<h1><span id="e-k-th-largest-connected-components"><strong>E - K-th Largest Connected Components</strong></span></h1><h3><span id="problem-statement">Problem Statement</span></h3><p>There is an undirected graph with $N$ vertices and $0$ edges. The vertices are numbered $1$ to $N$.</p>
<p>You are given $Q$ queries to process in order. Each query is of one of the following two types:</p>
<ul>
<li><p>Type $1$: Given in the format <code>1 u v</code>. Add an edge between vertices $u$ and $v$.</p>
</li>
<li><p>Type $2$: Given in the format <code>2 v k</code>. Print the $k$-th largest vertex number among the vertices connected to vertex $v$. If there are fewer than $k$ vertices connected to $v$, print <code>-1</code>.</p>
</li>
</ul>
<h3><span id="constraints">Constraints</span></h3><ul>
<li>$1 \leq N, Q \leq 2 \times 10^5$</li>
<li>In a Type $1$ query, $1 \leq u &lt; v \leq N$.</li>
<li>In a Type $2$ query, $1 \leq v \leq N$, $1 \leq k \leq 10$.</li>
<li>All input values are integers.</li>
</ul>
<h3><span id="sample-input-1">Sample Input 1</span></h3><pre><code>4 10
1 1 2
2 1 1
2 1 2
2 1 3
1 1 3
1 2 3
1 3 4
2 1 1
2 1 3
2 1 5
</code></pre>
<h3><span id="sample-output-1">Sample Output 1</span></h3><pre><code>2
1
-1
4
2
-1
</code></pre>
<ul>
<li>In the first query, an edge is added between vertices $1$ and $2$.</li>
<li>In the second query, two vertices are connected to vertex $1$: $1$ and $2$. Among them, the $1$-st largest vertex number is $2$, which should be printed.</li>
<li>In the third query, two vertices are connected to vertex $1$: $1$ and $2$. Among them, the $2$-nd largest vertex number is $1$, which should be printed.</li>
<li>In the fourth query, two vertices are connected to vertex $1$: $1$ and $2$, which is fewer than $3$, so print <code>-1</code>.</li>
<li>In the fifth query, an edge is added between vertices $1$ and $3$.</li>
<li>In the sixth query, an edge is added between vertices $2$ and $3$.</li>
<li>In the seventh query, an edge is added between vertices $3$ and $4$.</li>
<li>In the eighth query, four vertices are connected to vertex $1$: $1,2,3,4$. Among them, the $1$-st largest vertex number is $4$, which should be printed.</li>
<li>In the ninth query, four vertices are connected to vertex $1$: $1,2,3,4$. Among them, the $3$-rd largest vertex number is $2$, which should be printed.</li>
<li>In the tenth query, four vertices are connected to vertex $1$: $1,2,3,4$, which is fewer than $5$, so print <code>-1</code>.</li>
</ul>
<h2><span id="实现">实现</span></h2><p>启发式合并+平衡树查询</p>
<pre><code class="c++">#include &lt;bits/stdc++.h&gt;
#include &lt;bits/extc++.h&gt;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
using namespace std;
#define int long long
typedef tree&lt;int, null_type, greater&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; Tree;
const int N = 2e6 + 10;
Tree tr[N];
int f[N];
int find(int x)&#123;
    return f[x]==x?x:f[x]=find(f[x]);
&#125;
void solve()&#123;
    int n,q;
    cin&gt;&gt;n&gt;&gt;q;
    for(int i=1;i&lt;=n;i++)&#123;
        tr[i].insert(i);
        f[i]=i;
    &#125;
    for(int i=1;i&lt;=q;i++)&#123;
        int st;
        cin&gt;&gt;st;
        if(st==1)&#123;
            int u,v;
            cin&gt;&gt;u&gt;&gt;v;
            u=find(u),v=find(v);
            if(u==v) continue;
            if(tr[u].size()&gt;tr[v].size())&#123;
                swap(u,v);
            &#125;
            for(auto it:tr[u])&#123;
                tr[v].insert(it);
                f[it]=v;
            &#125;
            tr[u].clear();
        &#125;
        else&#123;
            int v,k;
            cin&gt;&gt;v&gt;&gt;k;
            v=find(v);
            if(tr[v].size()&gt;=k)&#123;
                cout&lt;&lt;*tr[v].find_by_order(k-1)&lt;&lt;endl;
            &#125;
            else&#123;
                cout&lt;&lt;-1&lt;&lt;endl;
            &#125;
        &#125;
    &#125;
&#125;
signed main()&#123;
    int t=1;
    //cin &gt;&gt; t;
    while (t--) &#123;
        solve();
    &#125; 
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/atcoder-C/" style="color: #ffa2c4">-atcoder -C++</a>
        </span>
        
    </div>
    <a href="/2024/09/24/AtCoder-Beginner-Contest-372/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/20/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">
        <h2 class="post-title">单调队列</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                数据结构
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <!--toc-->

<h1><span id="琪露诺">琪露诺</span></h1><p>在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。</p>
<p>某一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在琪露诺来之前就已经跑到了河的对岸。于是琪露诺决定到河岸去追青蛙。</p>
<p>小河可以看作一列格子依次编号为 $0$ 到 $N$，琪露诺只能从编号小的格子移动到编号大的格子。而且琪露诺按照一种特殊的方式进行移动，当她在格子 $i$ 时，她只移动到区间 $[i+L,i+R]$ 中的任意一格。你问为什么她这么移动，这还不简单，因为她是笨蛋啊。</p>
<p>每一个格子都有一个冰冻指数 $A_i$，编号为 $0$ 的格子冰冻指数为 $0$。当琪露诺停留在那一格时就可以得到那一格的冰冻指数 $A_i$。琪露诺希望能够在到达对岸时，获取最大的冰冻指数，这样她才能狠狠地教训那只青蛙。</p>
<p>但是由于她实在是太笨了，所以她决定拜托你帮它决定怎样前进。</p>
<p>开始时，琪露诺在编号 $0$ 的格子上，只要她下一步的位置编号大于 $N$ 就算到达对岸。</p>
<h3><span id="样例输入-1">样例输入 #1</span></h3><pre><code>5 2 3
0 12 3 11 7 -2
</code></pre>
<h3><span id="样例输出-1">样例输出 #1</span></h3><pre><code>11
</code></pre>
<pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
#define endl &#39;\n&#39; 
const int N=2e6;
int a[N],dp[N],s[N];
deque&lt;int&gt;dq1,dq2;
int n,h;
deque&lt;int&gt;p;         
void solve()&#123;
    int n,l,r;
    cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;
    for(int i=0;i&lt;=n;i++)&#123;
        cin&gt;&gt;a[i];
    &#125;
    memset(dp,-127,sizeof(dp));
    int j=0;
    dp[0]=0;
    for(int i=l;i&lt;=n;i++)&#123;
        while(j&lt;=i-l)&#123;
            while(!p.empty()&amp;&amp;dp[j]&gt;=dp[p.back()])&#123;
                p.pop_back();
            &#125;
            p.push_back(j);
            j++;
        &#125;
        if(!p.empty()&amp;&amp;p.front()&lt;i-r) p.pop_front();
        dp[i]=dp[p.front()]+a[i];
    &#125;
    int ans=-1e9;
    for(int i=n-r+1;i&lt;=n;i++)&#123;
       ans=max(ans,dp[i]);
    &#125;
    cout&lt;&lt;ans&lt;&lt;endl;

&#125;

signed main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout &lt;&lt; fixed &lt;&lt; setprecision(12);
    int t=1;
    //cin&gt;&gt;t;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre>
<h1><span id="noip2017-普及组-跳房子">[NOIP2017 普及组] 跳房子</span></h1><p>跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。</p>
<p>跳房子的游戏规则如下：</p>
<p>在地面上确定一个起点，然后在起点右侧画 $n$ 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个 格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：</p>
<p>玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。</p>
<p>现在小 R 研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 $d$。小 R 希望改进他的机器人，如果他花 $g$ 个金币改进他的机器人，那么他的机器人灵活性就能增加 $g$，但是需要注意的是，每 次弹跳的距离至少为 $1$。具体而言，当 $g&lt;d$ 时，他的机器人每次可以选择向右弹跳的距离为 $d-g,d-g+1,d-g+2,\ldots,d+g-1,d+g$；否则当 $g \geq d$ 时，他的机器人每次可以选择向右弹跳的距离为 $1,2,3,\ldots,d+g-1,d+g$。</p>
<p>现在小 R 希望获得至少 $k$ 分，请问他至少要花多少金币来改造他的机器人。</p>
<p>若无论如何他都无法获得至少 $k$ 分，输出 $-1$。</p>
<h3><span id="样例输入-1">样例输入 #1</span></h3><pre><code>7 4 10
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2
</code></pre>
<h3><span id="样例输出-1">样例输出 #1</span></h3><pre><code>2
</code></pre>
<pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
#define endl &#39;\n&#39; 
const int N=2e6;
int n,d,k;
int x[N],s[N];
int dp[N];
deque&lt;int&gt;p;         
bool check(int mid)&#123;
    memset(dp,-127,sizeof(dp));
    p.clear();
    int l=max((int)1,d-mid);
    int r=min(d+mid,x[n]);
    int idx=0;
    int num=0;
    dp[0]=0;
    for(int i=1;i&lt;=n;i++)&#123;
        if(x[i]&gt;=l&amp;&amp;x[i]&lt;=r)&#123;
            idx=i;
            dp[idx]=s[idx];
            num=dp[idx];
            break;
        &#125;
    &#125;
    if(idx==0) return 0;
    for(int i=2;i&lt;=n;i++)&#123;
        while(x[idx]&lt;=x[i]-l)&#123;
            while(!p.empty()&amp;&amp;dp[idx]&gt;=dp[p.back()])&#123;
                p.pop_back();
            &#125;
            p.push_back(idx);
            idx++;
        &#125;
        while(!p.empty()&amp;&amp;x[p.front()]&lt;x[i]-r) p.pop_front();
        if(!p.empty())
            dp[i]=dp[p.front()]+s[i];
        num=max(num,dp[i]);
    &#125;
    if(num&gt;=k) return 1;
    else return 0;
&#125;
void solve()&#123;
    cin&gt;&gt;n&gt;&gt;d&gt;&gt;k;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;x[i]&gt;&gt;s[i];
    &#125;
    int l=0;
    int r=1e9;
    while(l&lt;r)&#123;
        int mid=l+r&gt;&gt;1;
        if(check(mid)) r=mid;
        else l=mid+1;
    &#125;
    if(l&gt;=1e9) l=-1;
    cout&lt;&lt;l&lt;&lt;endl;
&#125;

signed main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout &lt;&lt; fixed &lt;&lt; setprecision(12);
    int t=1;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre>
<h1><span id="切蛋糕">切蛋糕</span></h1><p>今天是小 Z 的生日，同学们为他带来了一块蛋糕。这块蛋糕是一个长方体，被用不同色彩分成了 $n$ 个相同的小块，每小块都有对应的幸运值。</p>
<p>小 Z 作为寿星，自然希望吃到的蛋糕的幸运值总和最大，但小 Z 最多又只能吃 $m(m\le n)$ 小块的蛋糕。</p>
<p>请你帮他从这 $n$ 小块中找出<strong>连续</strong>的 $k(1 \le k\le m)$ 块蛋糕，使得其上的总幸运值最大。</p>
<p><strong>形式化地</strong>，在数列 ${p_n}$ 中，找出一个子段 $[l,r](r-l+1\le m)$，最大化 $\sum\limits_{i&#x3D;l}^rp_i$。</p>
<h3><span id="样例输入-1">样例输入 #1</span></h3><pre><code>5 2
1 2 3 4 5
</code></pre>
<h3><span id="样例输出-1">样例输出 #1</span></h3><pre><code>9
</code></pre>
<pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
#define endl &#39;\n&#39; 
const int N=2e6;
int a[N],dp[N],s[N];
deque&lt;int&gt;dq1,dq2;
int n,h;
deque&lt;int&gt;p;         
void solve()&#123;
   int n,m;
   cin&gt;&gt;n&gt;&gt;m;
   int ans=0;
   for(int i=1;i&lt;=n;i++)&#123;
       cin&gt;&gt;a[i];
       s[i]=s[i-1]+a[i];
    &#125;
    int j=1;
    for(int i=1;i&lt;=n;i++)&#123;
        while(j&lt;=min(i+m-1,n))&#123;
            while(!p.empty()&amp;&amp;s[j]&gt;=s[p.back()])&#123;
                p.pop_back();
            &#125;
            p.push_back(j);
            j++;
        &#125;
        if(p.front()&lt;i) p.pop_front();
        ans=max(ans,s[p.front()]-s[i-1]);
    &#125;
    cout&lt;&lt;ans&lt;&lt;endl;
&#125;

signed main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout &lt;&lt; fixed &lt;&lt; setprecision(12);
    int t=1;
    //cin&gt;&gt;t;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="color: #ff7d73">-c++ -数据结构</a>
        </span>
        
    </div>
    <a href="/2024/09/20/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/17/The-2022-ICPC-Asia-Nanjing-Regional-Contest/">
        <h2 class="post-title">The 2022 ICPC Asia Nanjing Regional Contest</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E9%A2%98%E8%A7%A3/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/17
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <!--toc-->

<h1><span id="d-chat-program">D. Chat Program</span></h1><h2><span id="题目">题目</span></h2><p>You’re the researcher of the International Chat Program Company (ICPC). Today, you discover the following chat history when reviewing some research data.</p>
<p><strong>SUA (2022&#x2F;12&#x2F;04 23:01:25)</strong></p>
<p>I’m out of ideas for competitive programming problems! Please give me a problem about sequences.</p>
<p><strong>BOT (2022&#x2F;12&#x2F;04 23:01:27)</strong></p>
<p>Sure. Here is a competitive programming problem about sequences.</p>
<p>Given an integer sequence $a_1, a_2, \cdots, a_n$ of length $n$ and four other integers $k$, $m$, $c$ and $d$, your goal is to maximize the $k$-th largest element in the sequence.</p>
<p>To achieve the goal, you can perform the following operation at most once: select a continuous sub-array of length $m$ and add an arithmetic sequence with length $m$, initial term $c$ and common difference $d$ to the sub-array.</p>
<p>More formally, you can select an integer $p$ satisfying $1 \le p \le n - m + 1$ and add $(c + di)$ to $a_{p + i}$ for all $0 \le i &lt; m$.</p>
<p>Calculate the largest possible value of the $k$-th largest element in the sequence after at most one operation.</p>
<p>The $k$-th largest element in the sequence is the $k$-th element in the sorted sequence after sorting all elements from the largest to the smallest. For example, the $3$rd largest element in sequence ${5, 7, 1, 9}$ is $5$, while the $3$rd largest element in sequence ${9, 7, 5, 9}$ is $7$.</p>
<p><strong>SUA (2022&#x2F;12&#x2F;05 00:15:17)</strong></p>
<p>This problem seems difficult! Please teach me the solution.</p>
<p><strong>BOT (2022&#x2F;12&#x2F;05 00:15:30)</strong></p>
<p>Sure. Firstly, we can…</p>
<p>[DATA EXPUNGED]</p>
<p>Unfortunately, parts of the chat history are lost due to a disk failure. You’re amazed at how a chat program can create a competitive programming problem. To verify whether the chat program can create valid problems, you decide to try on this problem.</p>
<p><img src="https://joso-1302558797.cos.ap-nanjing.myqcloud.com//imgimage-20240917151751463.png" alt="image-20240917151751463"></p>
<h2><span id="思路">思路</span></h2><p>二分答案，如果一个数想成为数组中的第k大，那么就需要至少k-1个比他大的数存在，在check函数中，我们把比mid大的数字状态更新为1，不做考虑，所有状态为0的点在need数组中记录达到mid所需要的最小项数，现在要做的就是维护所有状态为0的点，让他们尽可能多的变成比mid大的数字，当这些数字满足&gt;&#x3D;k时，则当前的mid是满足条件的</p>
<p>因为等差数列是连续加在数组上的，那么不妨把这个等差数列想象成一个滑动窗口m，m的第i个数代表等差数列的第i项，在移动窗口的时候窗口尾部每扫描到一个为0的点，判断一下他的need是否小于m的尾项，如果是，就加入到一个优先队列里面（优先队列用来存储当前元素弹出的下标idx，根据idx的大小关系排序，越小的弹出时间越早），否则直接略过，在每一次挪动窗口加入值之后用while循环判断当前有多少元素已经不满足条件。遍历一遍维护优先队列的最大size即可，加上之前已经大于mid的元素个数与k进行比较。</p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N=2e5+10;
int n,k,m,c,d,a[N];
bool st[N];
int need[N];
bool check(int mid)&#123;
    for(int i=1;i&lt;=n;i++)&#123;  
        if(a[i]&gt;=mid) st[i]=1;
        else st[i]=0;
        need[i]=0;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        if(!st[i])&#123;
            if(mid-a[i]&lt;=c) need[i]=1;
            else&#123;
                if(d==0) need[i]=1e9; //公差为0时，首项不满足，之后任何一项都不会满足，所以need[i]记录无限大
                else
                need[i]=(mid-a[i]-c+(d-1))/d+1; 
            &#125;
        &#125;
    &#125;
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;
    for(int i=1;i&lt;=m;i++)&#123;
        if(st[i]==0&amp;&amp;need[i]&lt;=i) q.push(m+(i-need[i])+1);
    &#125;
    int ans=q.size();
    for(int i=m+1;i&lt;=n;i++)&#123;
        if(st[i]==0&amp;&amp;need[i]&lt;=m) q.push(i+(m-need[i])+1);
        while(!q.empty()&amp;&amp;q.top()&lt;=i)&#123;
            q.pop();
        &#125;
        ans=max(ans,(int)q.size());
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        if(st[i]) ans++;
    &#125;
    if(ans&gt;=k) return 0;
    else return 1;
&#125;
void solve()
&#123;
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m&gt;&gt;c&gt;&gt;d;
    for(int i=1;i&lt;=n;i++)&#123;
        cin&gt;&gt;a[i];
    &#125;
    int l=0,r=1e17;
    while(l&lt;r)&#123;
        int mid=l+r+1&gt;&gt;1;
        if(check(mid)) r=mid-1;
        else l=mid;
    &#125;
    cout&lt;&lt;l&lt;&lt;endl;
&#125;
signed main()
&#123;
    int t=1;
    while(t--)
    &#123;
        solve();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/ICPC/" style="color: #ffa2c4">-ICPC</a>
        </span>
        
    </div>
    <a href="/2024/09/17/The-2022-ICPC-Asia-Nanjing-Regional-Contest/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/16/Codeforces-Round-972-Div-2/">
        <h2 class="post-title">Codeforces Round 972 (Div. 2)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E9%A2%98%E8%A7%A3/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/16
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <!--toc-->

<h1><span id="c-lazy-narek">C. Lazy Narek</span></h1><h2><span id="题目">题目</span></h2><p>Narek is too lazy to create the third problem of this contest. His friend Artur suggests that he should use ChatGPT. ChatGPT creates $n$ problems, each consisting of $m$ letters, so Narek has $n$ strings. To make the problem harder, he combines the problems by selecting some of the $n$ strings <strong>possibly none</strong> and concatenating them <strong>without altering their order</strong>. His chance of solving the problem is defined as $score_n - score_c$, where $score_n$ is Narek’s score and $score_c$ is ChatGPT’s score.</p>
<p>Narek calculates $score_n$ by examining the selected string (he moves from left to right). He initially searches for the letter $\texttt{“n”}$, followed by $\texttt{“a”}$, $\texttt{“r”}$, $\texttt{“e”}$, and $\texttt{“k”}$. Upon finding all occurrences of these letters, he increments $score_n$ by $5$ and resumes searching for $\texttt{“n”}$ again (he doesn’t go back, and he just continues from where he left off).</p>
<p>After Narek finishes, ChatGPT scans through the array and increments $score_c$ by $1$ for each letter $\texttt{“n”}$, $\texttt{“a”}$, $\texttt{“r”}$, $\texttt{“e”}$, or $\texttt{“k”}$ that Narek fails to utilize (note that if Narek fails to complete the last occurrence by finding all of the $5$ letters, then all of the letters he used are counted in ChatGPT’s score $score_c$, and Narek doesn’t get any points if he doesn’t finish finding all the 5 letters).</p>
<p>Narek aims to maximize the value of $score_n - score_c$ by selecting the most optimal subset of the initial strings.</p>
<h2><span id="实现">实现</span></h2><p>定义dp[i] [j]为前i个字符串，最后一个字符串匹配到了j个字母（n–1,a–2,r–3,e–4,k–5），每一次更新当前字符串分别以前某个字符串需要的字母为开头开始计数，算出以这个字母开头的分数差，进行状态转移，最后在dp[n] [i]中枚举一下最优解减去i+1即为答案</p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N=2e3+10;
int a[N],b[N],ans;
int dp[N][6];
int sum[6],need[6];
map&lt;char,bool&gt;st;

string temp=&quot;?narek&quot;;
int n,m;
void init(string s)&#123;
    for(int i=1;i&lt;=5;i++) sum[i]=0,need[i]=i;
    for(int i=1;i&lt;=m;i++)&#123;
        if(st[s[i]])&#123;
            for(int j=1;j&lt;=5;j++)&#123;
                if(s[i]==temp[need[j]])&#123;
                    need[j]++;
                    if(need[j]==6) sum[j]+=5,need[j]=1;
                &#125;
                else sum[j]--;
            &#125;
        &#125;
    &#125;
&#125;
void solve()
&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i&lt;=n;i++)&#123;
        for(int j=1;j&lt;=6;j++)&#123;
            dp[i][j]=-1e4;
        &#125;
    &#125;
    dp[0][1]=0;
    for(int i=1;i&lt;=n;i++)&#123;
        string s;
        cin&gt;&gt;s;
        s=&#39; &#39;+s;
        init(s);
        for(int j=1;j&lt;=5;j++) dp[i][j]=dp[i-1][j];
        for(int j=1;j&lt;=5;j++) dp[i][need[j]]=max(dp[i][need[j]],dp[i-1][j]+sum[j]);
    &#125;
    int ans=0;
    for(int i=1;i&lt;=5;i++)&#123;
        ans=max(ans,dp[n][i]-i+1);
    &#125;
    cout&lt;&lt;ans&lt;&lt;endl;
&#125;
signed main()
&#123;
    st[&#39;n&#39;]=1,st[&#39;a&#39;]=1,st[&#39;r&#39;]=1,st[&#39;e&#39;]=1,st[&#39;k&#39;]=1;
    int t=1;
    cin&gt;&gt;t;
    while(t--)
    &#123;
        solve();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/codeforces/" style="color: #03a9f4">-codeforces</a>
        </span>
        
    </div>
    <a href="/2024/09/16/Codeforces-Round-972-Div-2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/13/%E8%AE%B0%E5%BD%95%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E6%95%B0%E7%9A%84dp/">
        <h2 class="post-title">记录最优方案数的dp</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/13
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1><span id="低价购买">低价购买</span></h1><h2><span id="题目描述">题目描述</span></h2><p>“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。</p>
<p>这里是某支股票的价格清单：</p>
<p>$$<br>\def\arraystretch{1.5}<br>\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline<br>\textsf{日期} &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 \cr\hline<br>\textsf{价格} &amp; 68 &amp; 69 &amp; 54 &amp; 64 &amp; 68 &amp; 64 &amp; 70 &amp; 67 &amp; 78 &amp; 62&amp; 98 &amp; 87 \cr\hline<br>\end{array}<br>$$<br>最优秀的投资者可以购买最多 $4$ 次股票，可行方案中的一种是：<br>$$<br>\def\arraystretch{1.5}<br>\begin{array}{|c|c|c|c|c|}\hline<br>\textsf{日期} &amp; 2 &amp; 5 &amp; 6 &amp; 10 \cr\hline<br>\textsf{价格} &amp; 69 &amp; 68 &amp; 64 &amp; 62 \cr\hline<br>\end{array}<br>$$</p>
<h2><span id="输入格式">输入格式</span></h2><p>第一行共一个整数 $N\ (1  \le  N  \le 5000)$，股票发行天数</p>
<p>第二行一行 $N$ 个整数，是每天的股票价格。保证是大小不超过 $2^{16}$ 的正整数。</p>
<h2><span id="输出格式">输出格式</span></h2><p>输出共一行两个整数，分别为最大购买次数和拥有最大购买次数的方案数（数据保证 $ \le 2^{31}$）当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这 $2$ 种方案被认为是相同的。</p>
<h3><span id="样例输入-1">样例输入 #1</span></h3><pre><code>12
68 69 54 64 68 64 70 67 78 62 98 87
</code></pre>
<h3><span id="样例输出-1">样例输出 #1</span></h3><pre><code>4 2
</code></pre>
<h2><span id="思路">思路</span></h2><p>令<strong>f[i]<strong>表示以数字</strong>a[i]<strong>结尾且长度为</strong>dp[i]<strong>的方案数，那么当</strong>a[i]!&#x3D;a[j]<strong>时，出现</strong>dp[i]&#x3D;dp[j]+1</strong>的情况，直接在**f[i]<strong>加上</strong>f[j]<strong>，但当</strong>a[j]&#x3D;a[i]<strong>时，因为我们对</strong>f[i]<strong>的定义可得，</strong>f[i]<strong>和</strong>f[j]**此时是有重合的，也就是说只保留一个最多方案的f[i]即可</p>
<p>最后遍历一遍数组，加上所有等于答案长度的方案数即可</p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
//#define int long long
const int N=1e5+10;
const int mod=1e9+7;
int dp[N],a[N];
int f[N];
void solve()
&#123;
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)&#123;
          cin&gt;&gt;a[i];
          dp[i]=f[i]=1;
    &#125;
    int ans1=1;
    for(int i = 2; i &lt;= n; i++) &#123;
          for(int j = 1; j &lt; i; j++)&#123;
               if(a[i] &lt; a[j]) &#123;
                    if(dp[i]&lt;dp[j]+1)&#123;
                         dp[i] = max(dp[i], dp[j] + 1);
                         f[i]=f[j];
                    &#125;
                    else if(dp[i]==dp[j]+1) f[i]+=f[j];
               &#125;
               if(a[i]==a[j]) dp[j]=f[j]=0;
          &#125;
          ans1 = max(ans1, dp[i]);
     &#125;
     int num=0;
     for(int i=1;i&lt;=n;i++)&#123;
          if(dp[i]==ans1) num+=f[i];
     &#125;
     cout&lt;&lt;ans1&lt;&lt;&#39; &#39;&lt;&lt;num&lt;&lt;endl;
&#125;
signed main()
&#123;
    int t=1;
    //cin&gt;&gt;t;
    while(t--)
    &#123;
        solve();
    &#125;
&#125;
</code></pre>
<p><strong>同样的记录背包最优方案数在acwing有一道板题</strong></p>
<p><img src="https://joso-1302558797.cos.ap-nanjing.myqcloud.com//imgimage-20240913105957884.png" alt="image-20240913105957884"></p>
<p><strong>这里用g[i]表示背包体积为i时的最优方案数</strong></p>
<p><strong>如果选第i个物品能做到让价值增加，那么舍弃掉原先的方案数，用g[j-v]的值来覆盖掉g[j];</strong></p>
<p><strong>如果选与不选对结果没有影响，即价值一样时，需要把两种状态的方案汇总到一起，g[j]+&#x3D;g[j-v];</strong></p>
<p><strong>最后的g[V]即是最优情况下的方案总和</strong></p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N=2e5+10;
const int mod=1e9+7;
int dp[N];
int a[N],b[N];
int n,V;
vector&lt;int&gt;e[N];
int g[N];

void solve()
&#123;
   int n,V;
   cin&gt;&gt;n&gt;&gt;V;
   for(int i=0;i&lt;=V;i++) g[i]=1;
   for(int i=1;i&lt;=n;i++)
   &#123;
        int v,w;
        cin&gt;&gt;v&gt;&gt;w;
        for(int j=V;j&gt;=v;j--)
        &#123;
            if(dp[j]&lt;dp[j-v]+w)
            &#123;
                dp[j]=dp[j-v]+w;
                g[j]=g[j-v];
            &#125;
            else if(dp[j]==dp[j-v]+w)
            &#123;
                g[j]+=g[j-v];
                g[j]%=mod;
            &#125;
        &#125;
   &#125;
   cout&lt;&lt;g[V]&lt;&lt;endl;
&#125;
signed main()
&#123;
    int t=1;
    //cin&gt;&gt;t;
    while(t--)
    &#123;
        solve();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c/" style="color: #ffa2c4">c++</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="color: #03a9f4">动态规划</a>
        </span>
        
    </div>
    <a href="/2024/09/13/%E8%AE%B0%E5%BD%95%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E6%95%B0%E7%9A%84dp/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/11/%E7%8A%B6%E5%8E%8Bdp/">
        <h2 class="post-title">状压dp</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/11
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <!-- toc -->

<ul>
<li><a href="#acwing-1064-%E5%B0%8F%E5%9B%BD%E7%8E%8B%E7%BA%BF%E6%80%A7%E7%8A%B6%E5%8E%8Bdp%E7%9B%AE%E6%A0%87%E7%8A%B6%E6%80%81%E4%BC%98%E5%8C%96">AcWing 1064. 小国王【线性状压DP+目标状态优化】</a></li>
<li><a href="#acwing-327-%E7%8E%89%E7%B1%B3%E7%94%B0%E7%BA%BF%E6%80%A7%E7%8A%B6%E5%8E%8Bdp%E7%9B%AE%E6%A0%87%E7%8A%B6%E6%80%81%E4%BC%98%E5%8C%96">AcWing 327. 玉米田【线性状压DP+目标状态优化】</a></li>
<li><a href="#noi2001-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0">[NOI2001] 炮兵阵地</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a><ul>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1">样例输入 #1</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1">样例输出 #1</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="acwing-1064-小国王线性状压dp目标状态优化">AcWing 1064. 小国王【线性状压DP+目标状态优化】</span></h1><p><img src="https://joso-1302558797.cos.ap-nanjing.myqcloud.com//imgimage-20240911025041124.png" alt="image-20240911025041124"></p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/03/4b0faf684f7c6dd7.png" alt="img"></p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N=1e5+10;
const int mod=1e9+7;
int n,k;
int cnt[N];
int dp[12][110][3000];
vector&lt;int&gt;head[N];
vector&lt;int&gt;state;
bool check(int st)&#123;
    for(int i=0;i&lt;n;i++)
        if((st&gt;&gt;i&amp;1)&amp;&amp;st&gt;&gt;(i+1)&amp;1) return 0;
    return 1;
&#125;
int count(int st)&#123;
    int res=0;
    for(int i=0;i&lt;n;i++)&#123;
        res+=st&gt;&gt;i&amp;1;
    &#125;
    return res;
&#125;
void solve()&#123;
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=0;i&lt;1&lt;&lt;n;i++)&#123;
        if(check(i)) state.push_back(i);
        cnt[i]=count(i);
    &#125;
    for(int i=0;i&lt;state.size();i++)&#123;
        for(int j=0;j&lt;state.size();j++)&#123;
            int x=state[i],y=state[j];
            if(((x&amp;y)==0)&amp;&amp;check(x|y)) head[i].push_back(j);
        &#125;
    &#125;
    dp[0][0][0]=1;
    for(int i=1;i&lt;=n+1;i++)&#123;
        for(int j=0;j&lt;=k;j++)&#123;
            for(int a=0;a&lt;state.size();a++)&#123;
                for(int b:head[a])&#123;
                    int c=cnt[state[a]];
                    if(j&gt;=c)&#123;
                        dp[i][j][a]+=dp[i-1][j-c][b];
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;dp[n+1][k][0]&lt;&lt;endl;
&#125;
signed main()&#123;
    int t=1;
    //cin&gt;&gt;t;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre>
<h1><span id="acwing-327-玉米田线性状压dp目标状态优化">AcWing 327. 玉米田【线性状压DP+目标状态优化】</span></h1><p><img src="https://joso-1302558797.cos.ap-nanjing.myqcloud.com//imgimage-20240911025428056.png" alt="image-20240911025428056"></p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N=1e5+10;
const int mod=1e8;
int n,k;
int cnt[N],a[110];
int dp[14][1&lt;&lt;14];
vector&lt;int&gt;head[1&lt;&lt;14];
vector&lt;int&gt;state;
bool check(int st)&#123;
    return !(st&amp;st&lt;&lt;1);
&#125;
int count(int st)&#123;
    int res=0;
    for(int i=0;i&lt;n;i++)&#123;
        res+=st&gt;&gt;i&amp;1;
    &#125;
    return res;
&#125;
void solve()&#123;
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)&#123;
        for(int j=1;j&lt;=m;j++)&#123;
            cin&gt;&gt;k,a[i]|=!k&lt;&lt;(j-1);
        &#125;
    &#125;
    for(int st=0;st&lt;1&lt;&lt;m;st++)&#123;
        if(check(st)) state.push_back(st);
    &#125;
    for(auto it:state)&#123;
        for(auto next_it:state)&#123;
            if(!(it&amp;next_it)) head[it].push_back(next_it);
        &#125;
    &#125;
    dp[0][0]=1;
    for(int i=1;i&lt;=n+1;i++)&#123;
        for(auto st:state)&#123;
            if(!(st&amp;a[i]))&#123;
                for(auto next_st:head[st])&#123;
                    dp[i][st]+=dp[i-1][next_st];
                    dp[i][st]%=mod;
                &#125;
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;dp[n+1][0]&lt;&lt;endl;
&#125;
signed main()&#123;
    int t=1;
    //cin&gt;&gt;t;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre>
<h1><span id="noi2001-炮兵阵地">[NOI2001] 炮兵阵地</span></h1><h2><span id="题目描述">题目描述</span></h2><p>司令部的将军们打算在 $N\times M$ 的网格地图上部署他们的炮兵部队。</p>
<p>一个 $N\times M$ 的地图由 $N$ 行 $M$ 列组成，地图的每一格可能是山地（用 $\texttt{H}$ 表示），也可能是平原（用 $\texttt{P}$ 表示），如下图。</p>
<p>在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/pic/1881.png"> </p>
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。</p>
<p>图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。</p>
<p>现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
<h3><span id="样例输入-1">样例输入 #1</span></h3><pre><code>5 4
PHPP
PPHH
PPPP
PHPP
PHHP
</code></pre>
<h3><span id="样例输出-1">样例输出 #1</span></h3><pre><code>6
</code></pre>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N=1e5+10;
const int mod=1e9+7;
int n,m;
char c;
int cnt[N],g[110];
int dp[2][1&lt;&lt;10][1&lt;&lt;10];
vector&lt;int&gt;head[N];
vector&lt;int&gt;state;
bool check(int st)&#123;
    return !(st&amp;st&gt;&gt;1||st&amp;st&gt;&gt;2);
&#125;
int count(int st)&#123;
    int res=0;
    for(int i=0;i&lt;m;i++)&#123;
        res+=st&gt;&gt;i&amp;1;
    &#125;
    return res;
&#125;
void solve()&#123;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)&#123;
        for(int j=1;j&lt;=m;j++)&#123;
            cin&gt;&gt;c, g[i]|=(c==&#39;H&#39;)&lt;&lt;(j-1);
        &#125;
    &#125;
    for(int st=0;st&lt;1&lt;&lt;m;st++)&#123;
        if(check(st)) state.push_back(st),cnt[st]=count(st);
    &#125;
    for(int x: state)&#123;
        for(int y: state)&#123;
            if(!(x&amp;y)) head[x].push_back(y);
        &#125;
    &#125;
    for(int i=1;i&lt;=n+2;i++)&#123;
        for(int st:state)&#123;
            if(!(st&amp;g[i]))&#123;
                for(int p1:head[st])&#123;
                    for(int p2:head[p1])&#123;
                        if(!(st&amp;p2))&#123;
                            dp[i&amp;1][st][p1]=max(dp[i&amp;1][st][p1],dp[i-1&amp;1][p1][p2]+cnt[st]);
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;dp[n+2&amp;1][0][0]&lt;&lt;endl;
&#125;
signed main()&#123;
    int t=1;
    //cin&gt;&gt;t;
    while(t--)&#123;
        solve();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c/" style="color: #ffa2c4">c++</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="color: #ff7d73">动态规划</a>
        </span>
        
    </div>
    <a href="/2024/09/11/%E7%8A%B6%E5%8E%8Bdp/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/10/AcWing-734-%E8%83%BD%E9%87%8F%E7%9F%B3/">
        <h2 class="post-title">AcWing 734. 能量石</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/10
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>岩石怪物杜达生活在魔法森林中，他在午餐时收集了 N 块能量石准备开吃。</p>
<p>由于他的嘴很小，所以一次只能吃一块能量石。</p>
<p>能量石很硬，吃完需要花不少时间。</p>
<p>吃完第 ii块能量石需要花费的时间为 Si秒。</p>
<p>杜达靠吃能量石来获取能量。</p>
<p>不同的能量石包含的能量可能不同。</p>
<p>此外，能量石会随着时间流逝逐渐失去能量。</p>
<p>第 ii块能量石最初包含 Ei 单位的能量，并且每秒将失去 Li 单位的能量。</p>
<p>当杜达开始吃一块能量石时，他就会立即获得该能量石所含的全部能量（无论实际吃完该石头需要多少时间）。</p>
<p>能量石中包含的能量最多降低至 0。</p>
<p>请问杜达通过吃能量石可以获得的最大能量是多少？</p>
<h4><span id="输入格式">输入格式</span></h4><p>第一行包含整数 T，表示共有 T 组测试数据。</p>
<p>每组数据第一行包含整数 N，表示能量石的数量。</p>
<p>接下来 N 行，每行包含三个整数 Si,Ei,Li</p>
<p>输出格式</p>
<p>每组数据输出一个结果，每个结果占一行。</p>
<p>结果表示为 <code>Case #x: y</code>，其中 xx 是组别编号（从 1 开始），y 是可以获得的最大能量值。</p>
<h4><span id="数据范围">数据范围</span></h4><p>1≤T≤10<br>1≤N≤100<br>1≤Si≤100<br>1≤Ei≤105<br>0≤Li≤105</p>
<h4><span id="输入样例">输入样例：</span></h4><pre><code>3
4
20 10 1
5 30 5
100 30 1
5 80 60
3
10 4 1000
10 3 1000
10 8 1000
2
12 300 50
5 200 0
</code></pre>
<h4><span id="输出样例">输出样例：</span></h4><pre><code>Case #1: 105
Case #2: 8
Case #3: 500
</code></pre>
<h4><span id="样例解释">样例解释</span></h4><p>在样例＃1中，有 N&#x3D;4 个宝石。杜达可以选择的一个吃石头顺序是：</p>
<ul>
<li>吃第四块石头。这需要 5 秒，并给他 80 单位的能量。</li>
<li>吃第二块石头。这需要 5 秒，并给他 5 单位的能量（第二块石头开始时具有 30 单位能量，5 秒后失去了 25 单位的能量）。</li>
<li>吃第三块石头。这需要 100 秒，并给他 20 单位的能量（第三块石头开始时具有 30 单位能量，10 秒后失去了 10 单位的能量）。</li>
<li>吃第一块石头。这需要 20 秒，并给他 0 单位的能量（第一块石头以 10 单位能量开始，110 秒后已经失去了所有的能量）。</li>
</ul>
<p>他一共获得了 105105 单位的能量，这是能获得的最大值，所以答案是 105。</p>
<p>在样本案例＃2中，有 N&#x3D;3 个宝石。</p>
<p>无论杜达选择吃哪块石头，剩下的两个石头的能量都会耗光。</p>
<p>所以他应该吃第三块石头，给他提供 8 单位的能量。</p>
<p>在样本案例＃3中，有 N&#x3D;2 个宝石。杜达可以：</p>
<ul>
<li>吃第一块石头。这需要 12 秒，并给他 300单位的能量。</li>
<li>吃第二块石头。这需要 5秒，并给他 200 单位的能量（第二块石头随着时间的推移不会失去任何能量！）。</li>
</ul>
<p>所以答案是 500。</p>
<pre><code class="c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N=2e5+10;
const int mod=1e9+7;
int dp[N];
struct tr
&#123;
    int s,e,l;
    bool operator &lt; (const tr &amp;a) const&#123;
        return s*a.l&lt;a.s*l;
    &#125;
&#125;tree[N];
int t,num=0;
void solve()
&#123;
    int n,m=0;
    cin&gt;&gt;n;
    memset(dp,-127,sizeof(dp));
    dp[0]=0;
    for(int i=1;i&lt;=n;i++)
    &#123;
        int s,e,l;
        cin&gt;&gt;s&gt;&gt;e&gt;&gt;l;
        tree[i]=&#123;s,e,l&#125;;
        m+=s;
    &#125;
    sort(tree+1,tree+1+n);
    for(int i=1;i&lt;=n;i++)
    &#123;
        for(int j=m;j&gt;=tree[i].s;j--)
        &#123;
            dp[j]=max(dp[j],dp[j-tree[i].s]+tree[i].e-tree[i].l*(j-tree[i].s));
        &#125;
    &#125;
    int ans=0;
    for(int i=0;i&lt;=m;i++)
    &#123;
        ans=max(ans,dp[i]);
    &#125;
    cout&lt;&lt;&quot;Case #&quot;&lt;&lt;num&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;
&#125;
signed main()
&#123;
    cin&gt;&gt;t;
    while(num&lt;t)
    &#123;
        num++;
        solve();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E2%80%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-c/" style="color: #00a596">— 动态规划 - c++</a>
        </span>
        
    </div>
    <a href="/2024/09/10/AcWing-734-%E8%83%BD%E9%87%8F%E7%9F%B3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/10/AtCoder-Beginner-Contest-370/">
        <h2 class="post-title">AtCoder Beginner Contest 370</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E9%A2%98%E8%A7%A3/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/10
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <!-- toc -->

<ul>
<li><a href="#d-cross-explosion"><strong>D - Cross Explosion</strong></a><ul>
<li><a href="#problem-statement">Problem Statement</a></li>
</ul>
</li>
<li><a href="#e-avoid-k-partition"><strong>E - Avoid K Partition</strong></a><ul>
<li><a href="#problem-statement-1">Problem Statement</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="d-cross-explosion"><strong>D - Cross Explosion</strong></span></h1><h3><span id="problem-statement">Problem Statement</span></h3><p>There is a grid with $H$ rows and $W$ columns. Let $(i, j)$ denote the cell at the $i$-th row from the top and $j$-th column from the left.<br>Initially, there is one wall in each cell.<br>After processing $Q$ queries explained below in the order they are given, find the number of remaining walls.</p>
<p>In the $q$-th query, you are given two integers $R_q$ and $C_q$.<br>You place a bomb at $(R_q, C_q)$ to destroy walls. As a result, the following process occurs.</p>
<ul>
<li>If there is a wall at $(R_q, C_q)$, destroy that wall and end the process.</li>
<li>If there is no wall at $(R_q, C_q)$, destroy the first walls that appear when looking up, down, left, and right from $(R_q, C_q)$. More precisely, the following four processes occur simultaneously:<ul>
<li>If there exists an $i \lt R_q$ such that a wall exists at $(i, C_q)$ and no wall exists at $(k, C_q)$ for all $i \lt k \lt R_q$, destroy the wall at $(i, C_q)$.</li>
<li>If there exists an $i \gt R_q$ such that a wall exists at $(i, C_q)$ and no wall exists at $(k, C_q)$ for all $R_q \lt k \lt i$, destroy the wall at $(i, C_q)$.</li>
<li>If there exists a $j \lt C_q$ such that a wall exists at $(R_q, j)$ and no wall exists at $(R_q, k)$ for all $j \lt k \lt C_q$, destroy the wall at $(R_q, j)$.</li>
<li>If there exists a $j \gt C_q$ such that a wall exists at $(R_q, j)$ and no wall exists at $(R_q, k)$ for all $C_q \lt k \lt j$, destroy the wall at $(R_q, j)$.</li>
</ul>
</li>
</ul>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fi first
#define se second
#define int long long

using namespace std;

typedef pair&lt;int, int&gt; PII;
typedef long long LL;

signed main() &#123;
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(0);

    int n, m, q;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;

    vector&lt;set&lt;int&gt;&gt; col(m + 1), lin(n + 1);
    vector&lt;vector&lt;bool&gt;&gt; st(n + 1, vector&lt;bool&gt;(m + 1, 0));
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++) col[j].insert(i), lin[i].insert(j), st[i][j] = 1;
    int res = n * m;
    while (q--) &#123;
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;

        if (st[x][y]) &#123;
            res--, st[x][y] = 0;
            col[y].erase(x), lin[x].erase(y);
            continue;
        &#125;
        auto up = col[y].upper_bound(x), down = up, left = lin[x].upper_bound(y), right = left;
        if (up != col[y].begin()) &#123;
            up--, res--, st[*up][y] = 0;
            col[y].erase(up), lin[*up].erase(y);
        &#125;
        if (down != col[y].end()) &#123;
            res--, st[*down][y] = 0;
            col[y].erase(down), lin[*down].erase(y);
        &#125;
        if (left != lin[x].begin()) &#123;
            left--, res--, st[x][*left] = 0;
            lin[x].erase(left), col[*left].erase(x);
        &#125;
        if (right != lin[x].end()) &#123;
            res--, st[x][*right] = 0;
            lin[x].erase(right), col[*right].erase(x);
        &#125;
    &#125;

    cout &lt;&lt; res &lt;&lt; endl;

    return 0;
&#125;
</code></pre>
<h1><span id="e-avoid-k-partition"><strong>E - Avoid K Partition</strong></span></h1><h3><span id="problem-statement">Problem Statement</span></h3><p>You are given a sequence $A &#x3D; (A_1, A_2, \dots, A_N)$ of length $N$ and an integer $K$.<br>There are $2^{N-1}$ ways to divide $A$ into several contiguous subsequences. How many of these divisions have no subsequence whose elements sum to $K$? Find the count modulo $998244353$.</p>
<p>Here, “to divide $A$ into several contiguous subsequences” means the following procedure.</p>
<ul>
<li>Freely choose the number $k$ $(1 \leq k \leq N)$ of subsequences and an integer sequence $(i_1, i_2, \dots, i_k, i_{k+1})$ satisfying $1 &#x3D; i_1 \lt i_2 \lt \dots \lt i_k \lt i_{k+1} &#x3D; N+1$.</li>
<li>For each $1 \leq n \leq k$, the $n$-th subsequence is formed by taking the $i_n$-th through $(i_{n+1} - 1)$-th elements of $A$, maintaining their order.</li>
</ul>
<p>Here are some examples of divisions for $A &#x3D; (1, 2, 3, 4, 5)$:</p>
<ul>
<li>$(1, 2, 3), (4), (5)$</li>
<li>$(1, 2), (3, 4, 5)$</li>
<li>$(1, 2, 3, 4, 5)$</li>
</ul>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fi first
#define se second
#define int long long

using namespace std;

typedef pair&lt;int, int&gt; PII;
typedef long long LL;

const int mod = 998244353;

signed main() &#123;
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(0);

    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;int&gt; a(n + 1), s(n + 1, 0);
    for (int i = 1; i &lt;= n; i ++)
        cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];

    vector&lt;int&gt; dp(n + 1, 0);
    unordered_map&lt;int, int&gt; tot;
    dp[0] = 1, tot[0] = 1;
    int sum = 1;
    for (int i = 1; i &lt;= n; i ++) &#123;
        dp[i] = (sum - tot[s[i] - k] + mod) % mod;
        (sum += dp[i]) %= mod, (tot[s[i]] += dp[i]) %= mod;
    &#125;

    cout &lt;&lt; dp[n] &lt;&lt; endl;

    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/atcoder-C/" style="color: #00a596">-atcoder -C++</a>
        </span>
        
    </div>
    <a href="/2024/09/10/AtCoder-Beginner-Contest-370/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/06/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B100-E/">
        <h2 class="post-title">牛客小白月赛100 E</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E9%A2%98%E8%A7%A3/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/6
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1><span id="e-acm中的cm题">E-ACM中的CM题</span></h1><p>现在在你前面有 nnn 个地雷</p>
<p>刚刚学会瞬移的你决定排走所有地雷</p>
<p>遗憾的是，你的初始排雷能力 m&#x3D;0m &#x3D; 0m&#x3D;0，但你知道</p>
<p>当排雷能力为 mmm 时，你可以任何时刻在当前位置 lll 处将[l,l+m][l, l+m][l,l+m] 中的雷全部排走</p>
<p>也可以在任何时刻任何地点，将排雷能力从 mmm 变为 m+1m+1m+1 </p>
<p>以上两种操作都需要花费 1 的时间，但瞬移不花费时间！</p>
<p>求排所有雷所需最小时间！</p>
<h2><span id="思路">思路</span></h2><p>枚举m长度二分求次数即可</p>
<pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int N = 2e5 + 10;
int a[N];
int n, ans;
void check(int len) &#123;
    int res = len - 1;
    for (int i = 1; i &lt;= n; i++) &#123;
        int l = i, r = n;
        while (l &lt; r) &#123;
            int mid = (l + r + 1) / 2;
            if (a[mid] - a[i] + 1 &gt; len)
                r = mid - 1;
            else
                l = mid;
        &#125;
        res++;
        i = l;
        if (l == n)
            break;
    &#125;
    ans = min(ans, res);
&#125;

void solve() &#123;
    int num;
    cin &gt;&gt; num;
    n = 0;
    map&lt;int, int&gt; mp;
    for (int i = 1; i &lt;= num; i++) &#123;
        int x;
        cin &gt;&gt; x;
        if (!mp[x]) &#123;
            a[++n] = x;
        &#125;
        mp[x] = 1;
    &#125;
    ans = n;
    sort(a + 1, a + 1 + n);
    for (int i = 1; i &lt;= n; i++) &#123;
        check(i);
    &#125;
    cout &lt;&lt; ans &lt;&lt; endl;
&#125;
signed main() &#123;
    int t = 1;
    while (t--) &#123;
        solve();
    &#125;
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c/" style="color: #00a596">c++</a>
        </span>
        
    </div>
    <a href="/2024/09/06/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B100-E/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <a class="page-num" href="/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">2</span>
    
    <a class="page-num" href="/page/3">
        3
    </a>
    
    
    
    
    <a class="page-num" href="/page/3/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">joso</div>
        <div class="description">
            <p>齐鲁工业大学（山东省科学院）</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://joso233.github.io/">joso&#39;blog</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 叫兽の窝
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;joso
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"left","width":150,"height":350},"mobile":{"show":true},"react":{"opacity":0.7},"dialog":{"enable":true,"hitokoto":true},"log":false});</script></body>
<script src="https://giscus.app/client.js"
        data-repo="joso233/remark"
        data-repo-id="R_kgDOMqyotg"
        data-category="Announcements"
        data-category-id="DIC_kwDOMqyots4CiGn3"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
 </script>
</html>
